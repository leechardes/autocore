# üì° Arquitetura MQTT - AutoCore

## Vis√£o Geral

O AutoCore utiliza MQTT como protocolo principal de comunica√ß√£o entre todos os componentes do sistema. O Mosquitto atua como broker central, coordenando mensagens entre dispositivos ESP32, aplica√ß√µes web, mobile e o gateway.

> **üìå Nota Importante:** A partir da vers√£o 2.0, toda configura√ß√£o de dispositivos √© feita via **API REST**. O MQTT √© usado exclusivamente para telemetria, comandos, status e heartbeat em tempo real.

## üèóÔ∏è Componentes do Sistema

### 1. Mosquitto Broker
- **Fun√ß√£o**: Broker MQTT central
- **Porta**: 1883 (desenvolvimento), 8883 (produ√ß√£o com TLS)
- **Host**: Raspberry Pi Zero 2W (mesmo do Gateway)
- **Configura√ß√£o**: 
  - Mensagens retidas para status
  - QoS 0 para telemetria (performance)
  - QoS 1 para comandos (garantia de entrega)
  - QoS 2 para configura√ß√µes cr√≠ticas (exatamente uma vez)

### 2. AutoCore Gateway
- **Fun√ß√£o**: Coordenador central e bridge
- **Responsabilidades**:
  - Descoberta autom√°tica de dispositivos
  - Roteamento inteligente de mensagens
  - Persist√™ncia de dados em SQLite
  - Bridge para servi√ßos cloud (futuro)
  - Gerenciamento de autentica√ß√£o
  - Monitoramento de sa√∫de do sistema

### 3. Interfaces de Controle (Clientes MQTT)

#### Config App (Web) 
- **Fun√ß√£o**: Interface de configura√ß√£o e monitoramento
- **Papel no Sistema**:
  - Configura√ß√£o inicial de dispositivos
  - Monitoramento em tempo real via WebSocket
  - Simuladores para desenvolvimento/teste
  - Debug e troubleshooting
- **Controle de Rel√©s**:
  - Interface de teste e valida√ß√£o
  - N√£o requer heartbeat (ambiente controlado)

#### ESP32 Display
- **Fun√ß√£o**: Interface f√≠sica no ve√≠culo
- **Papel no Sistema**:
  - Controle local via tela touch
  - Visualiza√ß√£o de telemetria em tempo real
  - **ENVIA HEARTBEATS** para rel√©s moment√¢neos
  - Renderiza√ß√£o de telas configur√°veis
- **Responsabilidades Cr√≠ticas**:
  - Manter heartbeat enquanto bot√£o pressionado
  - Parar heartbeat ao soltar ou perder touch
  - Feedback visual do estado dos rel√©s

#### Flutter App (Mobile/Desktop)
- **Fun√ß√£o**: Controle remoto multiplataforma
- **Papel no Sistema**:
  - Controle total do ve√≠culo via smartphone
  - **ENVIA HEARTBEATS** para rel√©s moment√¢neos
  - Notifica√ß√µes push de alertas
  - Visualiza√ß√£o de telemetria
- **Responsabilidades Cr√≠ticas**:
  - Manter heartbeat durante press & hold
  - Gerenciar reconex√£o em caso de perda de rede
  - Modo offline com sincroniza√ß√£o posterior

### 4. Dispositivos ESP32 (Hardware)

#### ESP32 Relay
- **Fun√ß√£o**: Controle de rel√©s automotivos
- **Caracter√≠sticas**:
  - 16/32 canais por placa
  - Prote√ß√£o por senha/confirma√ß√£o
  - Estado persistente em caso de reset

#### ESP32 Display
- **Fun√ß√£o**: Interface visual no ve√≠culo
- **Caracter√≠sticas**:
  - Telas configur√°veis (2.4" a 7")
  - Touch screen opcional
  - Renderiza√ß√£o de telemetria em tempo real

#### ESP32 CAN
- **Fun√ß√£o**: Interface com ECU do ve√≠culo
- **Caracter√≠sticas**:
  - Leitura de sinais CAN Bus
  - Suporte FuelTech, MegaSquirt, Haltech
  - Tradu√ß√£o CAN ‚Üí MQTT

#### ESP32 Sensor
- **Fun√ß√£o**: Leitura de sensores anal√≥gicos/digitais
- **Caracter√≠sticas**:
  - Temperatura, press√£o, n√≠vel
  - Calibra√ß√£o remota
  - Filtros de ru√≠do

### 5. Flutter App (Mobile/Desktop)
- **Fun√ß√£o**: Controle remoto completo
- **Plataformas**: iOS, Android, Windows, macOS, Linux
- **Caracter√≠sticas**:
  - Controle de rel√©s
  - Visualiza√ß√£o de telemetria
  - Notifica√ß√µes push
  - Modo offline com sincroniza√ß√£o

## üéØ Matriz de Responsabilidades

| Componente | Publica | Subscreve | Heartbeat | Responsabilidade Principal |
|------------|---------|-----------|-----------|---------------------------|
| **ESP32 Relay** | - Estado dos rel√©s<br>- Telemetria<br>- Safety events | - Comandos de controle<br>- Heartbeats | **RECEBE** e monitora | Executar comandos com seguran√ßa |
| **ESP32 Display** | - Touch events<br>- Comandos rel√©<br>- Heartbeats | - Estado dos rel√©s<br>- Telemetria CAN | **ENVIA** continuamente | Interface local no ve√≠culo |
| **Flutter App** | - Comandos rel√©<br>- Heartbeats<br>- Requisi√ß√µes | - Estado dos rel√©s<br>- Telemetria<br>- Notifica√ß√µes | **ENVIA** continuamente | Controle remoto completo |
| **Config App** | - Comandos teste | - Todos (monitor)<br>- Estados | N√£o necess√°rio | Configura√ß√£o via API e debug |
| **Gateway** | - Roteamento<br>- Agrega√ß√µes<br>- Comandos | - Tudo (broker) | N√£o aplic√°vel | Coordena√ß√£o e persist√™ncia |
| **ESP32 CAN** | - Telemetria CAN<br>- Status | - Comandos | N√£o aplic√°vel | Bridge CAN‚ÜíMQTT |
| **ESP32 Sensor** | - Dados sensores<br>- Status | - Comandos<br>- Calibra√ß√£o | N√£o aplic√°vel | Aquisi√ß√£o de dados |

## üìä Estrutura de T√≥picos MQTT

### Conven√ß√£o de Nomenclatura
```
autocore/{categoria}/{device_uuid}/{recurso}/{a√ß√£o}
```

### Categorias Principais

#### 1. Dispositivos (`devices`)
```
# Status do dispositivo
autocore/devices/{uuid}/status
autocore/devices/{uuid}/announce

# Recursos espec√≠ficos por tipo
autocore/devices/{uuid}/relays/state
autocore/devices/{uuid}/relays/set
autocore/devices/{uuid}/relays/heartbeat
autocore/devices/{uuid}/display/screen
autocore/devices/{uuid}/display/touch
autocore/devices/{uuid}/sensors/data
```

#### 2. Telemetria (`telemetry`)
```
# Dados de sensores
autocore/telemetry/sensors/{sensor_id}
autocore/telemetry/can/{signal_name}
autocore/telemetry/calculated/{metric}

# Telemetria de dispositivos
autocore/telemetry/relays
autocore/telemetry/displays

# Agrega√ß√µes
autocore/telemetry/summary/minute
autocore/telemetry/summary/hour
```

#### 3. Sistema (`system`)
```
# Gateway
autocore/gateway/status
autocore/gateway/stats

# Descoberta
autocore/discovery/announce
autocore/discovery/request

# Broadcast
autocore/system/broadcast
autocore/system/alert
autocore/system/update
```

#### 4. Comandos (`commands`)
```
# Comandos globais
autocore/commands/all/{action}
autocore/commands/group/{group_id}/{action}
autocore/commands/device/{uuid}/{action}
```


## üîÑ Fluxos de Comunica√ß√£o

### 1. Descoberta de Dispositivo
```mermaid
sequenceDiagram
    ESP32->>Broker: PUBLISH autocore/discovery/announce
    Gateway->>Broker: SUBSCRIBE autocore/discovery/+
    Gateway->>Database: Registrar dispositivo
    ESP32->>API: GET /api/config/{uuid}
    ESP32->>Broker: PUBLISH autocore/devices/{uuid}/status
```

### 2. Comando de Rel√© Toggle (App ‚Üí ESP32)
```mermaid
sequenceDiagram
    FlutterApp->>Broker: PUBLISH autocore/devices/{uuid}/relays/set
    ESP32Relay->>Broker: SUBSCRIBE autocore/devices/{uuid}/relays/set
    ESP32Relay->>Hardware: Acionar rel√©
    ESP32Relay->>Broker: PUBLISH autocore/devices/{uuid}/relays/state
    FlutterApp->>Broker: SUBSCRIBE autocore/devices/{uuid}/relays/state
    Display->>Broker: SUBSCRIBE autocore/devices/{uuid}/relays/state
```

### 2.1. Comando de Rel√© Moment√¢neo com Heartbeat
```mermaid
sequenceDiagram
    participant User
    participant Client as Display/App
    participant Broker as Mosquitto
    participant Relay as ESP32 Relay
    
    User->>Client: Press & Hold
    Client->>Broker: PUBLISH autocore/devices/{uuid}/relays/set {state: true, momentary: true}
    Relay->>Broker: SUBSCRIBE autocore/devices/{uuid}/relays/set
    Relay->>Relay: Liga rel√© + Inicia monitor timeout
    
    loop Enquanto pressionado (cada 500ms)
        Client->>Broker: PUBLISH autocore/devices/{uuid}/relays/heartbeat {channel: 1}
        Relay->>Relay: Reset timeout counter
    end
    
    User->>Client: Release
    Client->>Broker: PUBLISH autocore/devices/{uuid}/relays/set {state: false}
    Relay->>Relay: Desliga rel√©
    
    Note over Relay: Se timeout > 1s sem heartbeat
    Relay->>Relay: DESLIGA AUTOMATICAMENTE
    Relay->>Broker: PUBLISH autocore/telemetry/relays {uuid: "esp32-relay-001", event: "safety_shutoff"}
```

### 3. Telemetria CAN
```mermaid
sequenceDiagram
    ECU->>ESP32CAN: CAN Bus data
    ESP32CAN->>Broker: PUBLISH autocore/telemetry/can/+
    Gateway->>Broker: SUBSCRIBE autocore/telemetry/can/+
    Gateway->>Database: Armazenar telemetria
    Display->>Broker: SUBSCRIBE autocore/telemetry/can/+
    FlutterApp->>Broker: SUBSCRIBE autocore/telemetry/can/+
```

### 4. Evento Touch no Display
```mermaid
sequenceDiagram
    User->>ESP32Display: Touch event
    ESP32Display->>Broker: PUBLISH autocore/devices/{uuid}/display/touch
    Gateway->>Broker: SUBSCRIBE autocore/devices/{uuid}/display/touch
    Gateway->>Broker: PUBLISH autocore/devices/{relay_uuid}/relays/set
    ESP32Relay->>Broker: SUBSCRIBE autocore/devices/{relay_uuid}/relays/set
```

## üì¶ Formato de Mensagens (Payloads)

### Status do Dispositivo
```json
{
  "uuid": "esp32-relay-001",
  "type": "esp32_relay",
  "status": "online",
  "timestamp": "2025-08-08T10:30:00Z",
  "uptime": 3600,
  "firmware_version": "1.0.0",
  "ip_address": "192.168.1.100",
  "wifi_signal": -65,
  "free_memory": 45000
}
```

### Estado de Rel√©s
```json
{
  "uuid": "esp32-relay-001",
  "board_id": 1,
  "timestamp": "2025-08-08T10:30:00Z",
  "channels": {
    "1": true,
    "2": false,
    "3": true,
    "4": false
  }
}
```

### Comando de Rel√© Toggle
```json
{
  "channel": 1,
  "state": true,
  "function_type": "toggle",
  "user": "mobile_app",
  "timestamp": "2025-08-08T10:30:00Z"
}
```

### Comando de Rel√© Moment√¢neo
```json
{
  "channel": 1,
  "state": true,
  "function_type": "momentary",
  "momentary": true,
  "user": "display_touch",
  "timestamp": "2025-08-08T10:30:00Z"
}
```

### Heartbeat de Rel√© Moment√¢neo
```json
{
  "channel": 1,
  "source_uuid": "esp32-display-001",
  "target_uuid": "esp32-relay-001",
  "timestamp": "2025-08-08T10:30:00Z",
  "sequence": 42
}
```

### Telemetria de Relay (Evento de Mudan√ßa)
```json
{
  "uuid": "esp32-relay-001",
  "board_id": 1,
  "timestamp": "2025-08-12T12:46:34.914991",
  "event": "relay_change",
  "channel": 2,
  "state": false,
  "trigger": "simulator"
}
```

### Evento de Safety Shutoff
```json
{
  "uuid": "esp32-relay-001",
  "board_id": 1,
  "event": "safety_shutoff",
  "channel": 1,
  "reason": "heartbeat_timeout",
  "timeout_ms": 1000,
  "last_heartbeat": "2025-08-08T10:30:00Z",
  "timestamp": "2025-08-08T10:30:01Z"
}
```

### Telemetria CAN
```json
{
  "timestamp": "2025-08-08T10:30:00Z",
  "signals": {
    "RPM": {
      "value": 2500,
      "unit": "rpm",
      "can_id": "0x200"
    },
    "TPS": {
      "value": 45.2,
      "unit": "%",
      "can_id": "0x201"
    },
    "ECT": {
      "value": 87.5,
      "unit": "¬∞C",
      "can_id": "0x202"
    }
  }
}
```

### Evento Touch
```json
{
  "screen_id": 1,
  "item_id": 5,
  "action": "tap",
  "position": {
    "x": 150,
    "y": 200
  },
  "timestamp": "2025-08-08T10:30:00Z"
}
```


## üîí Seguran√ßa

### Sistema de Heartbeat para Rel√©s Moment√¢neos

#### Problema Resolvido
Rel√©s moment√¢neos (buzina, guincho, partida) devem desligar automaticamente se:
- Perda de conex√£o de rede
- Travamento do aplicativo
- Falha no cliente MQTT
- Timeout de comunica√ß√£o

#### Implementa√ß√£o
1. **Cliente (Display/App)**:
   - Envia heartbeat a cada 500ms enquanto bot√£o pressionado
   - Para heartbeat ao soltar bot√£o
   - Envia comando OFF expl√≠cito ao soltar

2. **ESP32 Relay**:
   - Monitora heartbeats recebidos
   - Timeout de 1 segundo sem heartbeat
   - Desliga automaticamente por seguran√ßa
   - Publica evento `safety_shutoff` para auditoria

3. **Par√¢metros Configur√°veis**:
   - `heartbeat_interval`: 500ms (frequ√™ncia de envio)
   - `heartbeat_timeout`: 1000ms (timeout para desligar)
   - `retry_count`: 3 (tentativas antes de desligar)

#### Tipos de Rel√©
- **Toggle**: Liga/desliga com clique simples
- **Momentary**: Liga enquanto pressionado (requer heartbeat)
- **Pulse**: Liga por tempo determinado e desliga
- **Timed**: Liga com timer configur√°vel

### Desenvolvimento
- Sem autentica√ß√£o (rede local isolada)
- Conex√µes n√£o criptografadas
- Todas as mensagens em texto claro
- Simuladores para teste sem hardware

### Produ√ß√£o (Planejado)
- TLS/SSL na porta 8883
- Autentica√ß√£o por usu√°rio/senha
- ACL (Access Control Lists) por t√≥pico
- Tokens JWT para comandos cr√≠ticos
- Criptografia de payloads sens√≠veis
- Rate limiting por cliente

## üìà Quality of Service (QoS)

### QoS 0 - Fire and Forget
- Telemetria de sensores
- Status peri√≥dico
- Dados n√£o cr√≠ticos

### QoS 1 - At Least Once
- Comandos de rel√©s
- Alertas
- Heartbeats

### QoS 2 - Exactly Once
- Atualiza√ß√µes de firmware
- Comandos cr√≠ticos de seguran√ßa
- Comandos financeiros (futuro)

## üîÑ Retained Messages

Mensagens que devem ser retidas:
- `autocore/devices/{uuid}/status` - √öltimo status conhecido
- `autocore/devices/{uuid}/relays/state` - Estado atual dos rel√©s
- `autocore/gateway/status` - Status do gateway

## üìä M√©tricas e Monitoramento

### M√©tricas Coletadas
- Mensagens por segundo
- Lat√™ncia m√©dia
- Dispositivos online
- Taxa de erro
- Uso de banda

### T√≥picos de Monitoramento
```
autocore/metrics/messages_per_second
autocore/metrics/connected_clients
autocore/metrics/average_latency
autocore/metrics/error_rate
```

## üöÄ Otimiza√ß√µes

### Para Raspberry Pi Zero 2W
1. **Batch de mensagens** - Agrupar telemetria em intervalos
2. **Compress√£o** - gzip para payloads grandes
3. **Rate limiting** - M√°ximo 10 msgs/segundo por dispositivo
4. **Cache local** - SQLite para dados hist√≥ricos
5. **Filtros no broker** - Reduzir tr√°fego desnecess√°rio

### Para ESP32
1. **Buffer de mensagens** - Queue para reconex√£o
2. **Heartbeat otimizado** - 30 segundos
3. **Payload m√≠nimo** - Apenas campos alterados
4. **Sleep mode** - Entre transmiss√µes

## üîÆ Evolu√ß√£o Futura

### Fase 1 - Local (Atual)
- Comunica√ß√£o local via Mosquitto
- Sem autentica√ß√£o
- Interface web de configura√ß√£o

### Fase 2 - Seguran√ßa
- TLS/SSL
- Autentica√ß√£o e autoriza√ß√£o
- Logs de auditoria

### Fase 3 - Cloud Bridge
- Bridge para AWS IoT / Azure IoT
- Backup em cloud
- An√°lise de dados hist√≥ricos

### Fase 4 - IA e Automa√ß√£o
- Detec√ß√£o de anomalias
- Automa√ß√µes baseadas em padr√µes
- Manuten√ß√£o preditiva

## üìù Boas Pr√°ticas

### Nomenclatura de T√≥picos
- Usar lowercase com underscore
- UUID √∫nico por dispositivo
- Versioning em t√≥picos cr√≠ticos
- Evitar caracteres especiais

### Payloads
- JSON para legibilidade
- MessagePack para performance (futuro)
- Sempre incluir timestamp
- Versioning de schema

### Conex√£o
- Reconnect autom√°tico com backoff
- Last Will Testament configurado
- Client ID √∫nico e persistente
- Clean session = false para QoS > 0

## üõ†Ô∏è Ferramentas de Debug

### Linha de Comando
```bash
# Subscrever em todos os t√≥picos
mosquitto_sub -h localhost -t "autocore/#" -v

# Publicar mensagem de teste
mosquitto_pub -h localhost -t "autocore/test" -m '{"test": true}'

# Monitor de performance
mosquitto_sub -h localhost -t "$SYS/#" -v
```

### GUI
- MQTT Explorer (Windows/Mac/Linux)
- MQTT.fx (Java-based)
- MQTTLens (Chrome extension)

### Program√°tico
- Config App - Monitor MQTT
- Flutter App - Debug console
- Gateway logs - `/var/log/autocore/`

---

**√öltima Atualiza√ß√£o:** 12 de Agosto de 2025  
**Vers√£o:** 2.1.0  
**Maintainer:** AutoCore Team

### Changelog
- v2.1.0 - Removida configura√ß√£o via MQTT (migrado para API REST)
- v2.1.0 - Atualizada estrutura de t√≥picos e fluxos
- v2.0.0 - Adicionado sistema de heartbeat para rel√©s moment√¢neos
- v2.0.0 - Documentado papel espec√≠fico de cada componente
- v2.0.0 - Adicionada matriz de responsabilidades
- v1.0.0 - Documenta√ß√£o inicial da arquitetura MQTT
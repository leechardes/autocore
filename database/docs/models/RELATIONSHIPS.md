# üîó Database Relationships Map

Mapeamento completo de todos os relacionamentos entre models do AutoCore com SQLAlchemy.

## üìã Vis√£o Geral

O AutoCore utiliza relacionamentos SQLAlchemy bem definidos para manter integridade referencial e facilitar queries complexas. Todos os relacionamentos seguem padr√µes consistentes com `back_populates` e cascade adequado.

### üéØ Tipos de Relacionamentos
- **1:N** (One-to-Many) - Relacionamento pai-filhos
- **N:1** (Many-to-One) - Relacionamento filho-pai  
- **1:1** (One-to-One) - Relacionamento exclusivo
- **Self-Reference** - Relacionamento auto-referencial

## üó∫Ô∏è Relationship Overview

```
Device (1) ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ (N) RelayBoard ‚îÄ‚îÄ‚îÄ‚îÄ (1:N) ‚îÄ‚îÄ‚îÄ‚îÄ RelayChannel (N)
             ‚îÇ                                      ‚Üë
             ‚îî‚îÄ‚îÄ (N) TelemetryData                  ‚îÇ
                                                    ‚îÇ (referenced by ID)
Screen (1) ‚îÄ‚îÄ‚îÄ‚îÄ (N) ScreenItem ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     ‚Üë                   ‚îÇ
     ‚îÇ (self-ref)         ‚îî‚îÄ‚îÄ (N:1) ‚îÄ‚îÄ‚îÄ‚îÄ User ‚îÄ‚îÄ‚îÄ‚îÄ (1:N) ‚îÄ‚îÄ‚îÄ‚îÄ EventLog
     ‚îÇ
     ‚îî‚îÄ‚îÄ Screen (parent/child)

Icon ‚îÄ‚îÄ‚îÄ‚îÄ (self-ref) ‚îÄ‚îÄ‚îÄ‚îÄ Icon (fallback)

# Standalone Models
Theme, Macro, CANSignal (no relationships)
```

## üîß Hardware Relationships

### Device ‚Üí RelayBoard (1:N)
```python
# Device Model
class Device(Base):
    relay_boards = relationship(
        "RelayBoard", 
        back_populates="device",
        cascade="all, delete-orphan"
    )

# RelayBoard Model  
class RelayBoard(Base):
    device_id = Column(Integer, ForeignKey('devices.id', ondelete='CASCADE'))
    device = relationship("Device", back_populates="relay_boards")
```

**Caracter√≠sticas:**
- **Cascade**: `all, delete-orphan` - Remove boards quando device √© deletado
- **ondelete**: `CASCADE` - FK constraint no database
- **Uso**: Um ESP32 pode ter m√∫ltiplas placas de rel√©

### RelayBoard ‚Üí RelayChannel (1:N)
```python
# RelayBoard Model
class RelayBoard(Base):
    channels = relationship(
        "RelayChannel",
        back_populates="board",
        cascade="all, delete-orphan"
    )

# RelayChannel Model
class RelayChannel(Base):
    board_id = Column(Integer, ForeignKey('relay_boards.id', ondelete='CASCADE'))
    board = relationship("RelayBoard", back_populates="channels")
```

**Caracter√≠sticas:**
- **Cascade**: `all, delete-orphan` - Remove channels quando board √© deletado
- **Constraint**: `UniqueConstraint('board_id', 'channel_number')` - Canal √∫nico por board
- **Uso**: Board de 16 canais tem 16 RelayChannels

### Device ‚Üí TelemetryData (1:N)
```python
# Device Model
class Device(Base):
    telemetry_data = relationship(
        "TelemetryData",
        back_populates="device",
        cascade="all, delete-orphan"
    )

# TelemetryData Model
class TelemetryData(Base):
    device_id = Column(Integer, ForeignKey('devices.id', ondelete='CASCADE'))
    device = relationship("Device", back_populates="telemetry_data")
```

**Caracter√≠sticas:**
- **Cascade**: `all, delete-orphan` - Remove telemetry quando device √© deletado
- **Volume**: Relacionamento de alta cardinalidade (muitos dados por device)
- **Uso**: Sensores, status, m√©tricas por device

## üñ•Ô∏è Interface Relationships

### Screen ‚Üí ScreenItem (1:N)
```python
# Screen Model
class Screen(Base):
    items = relationship(
        "ScreenItem",
        back_populates="screen",
        cascade="all, delete-orphan"
    )

# ScreenItem Model
class ScreenItem(Base):
    screen_id = Column(Integer, ForeignKey('screens.id', ondelete='CASCADE'))
    screen = relationship("Screen", back_populates="items")
```

**Caracter√≠sticas:**
- **Cascade**: `all, delete-orphan` - Remove items quando screen √© deletada
- **Order**: Items ordenados por `position`
- **Uso**: Tela dashboard com m√∫ltiplos elementos

### Screen ‚Üí Screen (Self-Reference)
```python
# Screen Model  
class Screen(Base):
    parent_id = Column(Integer, ForeignKey('screens.id'), nullable=True)
    
    # N√£o implementado como relationship (apenas FK)
    # Para evitar complexidade em queries
```

**Caracter√≠sticas:**
- **Tipo**: Self-reference opcional para hierarquia
- **Implementa√ß√£o**: Apenas FK, sem relationship object
- **Uso**: Submenus, telas aninhadas

## üîó Cross-Domain References

### ScreenItem ‚ü∑ RelayChannel (Reference by ID)
```python
# ScreenItem Model - N√ÉO √© relationship, apenas IDs
class ScreenItem(Base):
    relay_board_id = Column(Integer, ForeignKey('relay_boards.id', ondelete='SET NULL'))
    relay_channel_id = Column(Integer, ForeignKey('relay_channels.id', ondelete='SET NULL'))
    
    # SEM relationship objects - queries manual quando necess√°rio
```

**Caracter√≠sticas:**
- **Tipo**: Reference by ID (n√£o SQLAlchemy relationship)
- **ondelete**: `SET NULL` - Preserva ScreenItem se rel√© for removido
- **Valida√ß√£o**: Check constraint garante consist√™ncia
- **Uso**: Bot√£o controla rel√© espec√≠fico

### EventLog ‚Üí User (N:1)
```python
# EventLog Model
class EventLog(Base):
    user_id = Column(Integer, ForeignKey('users.id'), nullable=True)
    user = relationship("User")

# User Model - SEM back_populates para performance
class User(Base):
    # N√£o declara relationship para events
    pass
```

**Caracter√≠sticas:**
- **Tipo**: Unidirecional (EventLog ‚Üí User)
- **Nullable**: True - eventos de system n√£o t√™m user
- **Performance**: Evita carregar milhares de logs por user
- **Uso**: Auditoria e rastreamento de a√ß√µes

## üé® Resource Relationships

### Icon ‚Üí Icon (Self-Reference)
```python
# Icon Model
class Icon(Base):
    fallback_icon_id = Column(Integer, ForeignKey('icons.id', ondelete='SET NULL'))
    fallback_icon = relationship("Icon", remote_side=[id])
```

**Caracter√≠sticas:**
- **Tipo**: Self-reference opcional para fallback
- **remote_side**: `[id]` - Define dire√ß√£o do relationship
- **ondelete**: `SET NULL` - Remove refer√™ncia se fallback √© deletado
- **Uso**: √çcone espec√≠fico ‚Üí √≠cone gen√©rico

## üìä Relationship Patterns

### Cascade Strategies

#### `all, delete-orphan`
```python
# Usado em relacionamentos "ownership"
Device ‚Üí RelayBoard ‚Üí RelayChannel
Screen ‚Üí ScreenItem
```
- **Quando**: Parent "possui" completamente os children
- **Comportamento**: Remove children quando parent √© deletado
- **Uso**: Estruturas hier√°rquicas fortes

#### `SET NULL`
```python
# Usado em refer√™ncias opcionais
ScreenItem.relay_channel_id ‚Üí RelayChannel.id
Icon.fallback_icon_id ‚Üí Icon.id
```
- **Quando**: Refer√™ncia pode existir independentemente
- **Comportamento**: Limpa refer√™ncia, preserva records
- **Uso**: Cross-domain references

### Query Patterns

#### Eager Loading (joinedload)
```python
# Carregar device com todos os boards e channels
device_full = session.query(Device).options(
    joinedload(Device.relay_boards).joinedload(RelayBoard.channels)
).filter_by(uuid='device-uuid').first()

# Carregar screen com todos os items
screen_full = session.query(Screen).options(
    joinedload(Screen.items)
).filter_by(name='dashboard_main').first()
```

#### Lazy Loading (default)
```python
# Lazy loading autom√°tico quando acessado
device = session.get(Device, 1)
boards = device.relay_boards  # Query executada aqui
```

#### Subqueries para Counts
```python
# Count de channels por board sem carregar dados
board_stats = session.query(
    RelayBoard.id,
    func.count(RelayChannel.id).label('channel_count')
).outerjoin(RelayChannel).group_by(RelayBoard.id).all()
```

## üîç Cross-Reference Queries

### ScreenItem ‚Üí Relay Resolution
```python
def get_relay_channel_for_item(screen_item: ScreenItem) -> RelayChannel:
    """Resolve relay channel para screen item"""
    if screen_item.relay_channel_id:
        return session.get(RelayChannel, screen_item.relay_channel_id)
    return None

def get_screen_items_for_relay(relay_channel_id: int) -> List[ScreenItem]:
    """Encontra screen items que controlam este rel√©"""
    return session.query(ScreenItem).filter_by(
        relay_channel_id=relay_channel_id
    ).all()
```

### Event Correlation
```python
def get_device_events(device: Device) -> List[EventLog]:
    """Eventos relacionados a um device"""
    return session.query(EventLog).filter(
        or_(
            EventLog.source == device.uuid,
            EventLog.target == str(device.id)
        )
    ).order_by(EventLog.timestamp.desc()).all()

def get_relay_control_events(relay_channel_id: int) -> List[EventLog]:
    """Eventos de controle de um rel√© espec√≠fico"""
    return session.query(EventLog).filter(
        EventLog.event_type == 'relay_control',
        EventLog.target == str(relay_channel_id)
    ).order_by(EventLog.timestamp.desc()).all()
```

## üìà Performance Considerations

### Index Strategy por Relationship
```python
# FKs sempre indexadas automaticamente
# √çndices adicionais para performance

# Device relationships
Index('idx_devices_uuid', 'uuid')           # Device lookup
Index('idx_relay_boards_device', 'device_id')  # Board ‚Üí Device

# Screen relationships  
Index('idx_screen_items_screen_pos', 'screen_id', 'position')  # Ordered items

# Event relationships
Index('idx_events_timestamp', 'timestamp')   # Time-based queries
Index('idx_telemetry_timestamp', 'timestamp', 'device_id')  # Device telemetry
```

### Query Optimization
```python
# N+1 Query Problem - EVITAR
screens = session.query(Screen).all()
for screen in screens:
    items = screen.items  # Query por screen = N+1

# SOLU√á√ÉO: Eager loading
screens = session.query(Screen).options(
    joinedload(Screen.items)
).all()
for screen in screens:
    items = screen.items  # Dados j√° carregados
```

## üîß Relationship Maintenance

### Referential Integrity
```python
# Verificar integridade ap√≥s mudan√ßas
def check_referential_integrity():
    # ScreenItems √≥rf√£os
    orphaned_items = session.query(ScreenItem).outerjoin(Screen).filter(
        Screen.id.is_(None)
    ).count()
    
    # Channels √≥rf√£os
    orphaned_channels = session.query(RelayChannel).outerjoin(RelayBoard).filter(
        RelayBoard.id.is_(None)
    ).count()
    
    return {
        'orphaned_screen_items': orphaned_items,
        'orphaned_channels': orphaned_channels
    }
```

### Cleanup Operations
```python
# Limpar dados orf√£os (caso cascade falhe)
def cleanup_orphaned_data():
    # Remove screen items sem screen
    session.query(ScreenItem).filter(
        ScreenItem.screen_id.notin_(
            session.query(Screen.id)
        )
    ).delete(synchronize_session=False)
    
    # Remove telemetry antiga (>30 dias)
    old_date = datetime.now() - timedelta(days=30)
    session.query(TelemetryData).filter(
        TelemetryData.timestamp < old_date
    ).delete(synchronize_session=False)
    
    session.commit()
```

## üéØ Best Practices

### Relationship Definition
- ‚úÖ Sempre usar `back_populates` para clareza
- ‚úÖ Definir cascade apropriado (`all, delete-orphan` vs `SET NULL`)
- ‚úÖ Usar `ondelete` constraint no database
- ‚úÖ Indexes autom√°ticos em FKs

### Query Patterns
- ‚úÖ Usar `joinedload` para related data conhecida
- ‚úÖ Usar `selectinload` para collections grandes
- ‚úÖ Evitar N+1 queries com eager loading
- ‚úÖ Subqueries para counts e aggregations

### Cross-References
- ‚ö†Ô∏è IDs diretos para relacionamentos fracos
- ‚ö†Ô∏è Check constraints para valida√ß√£o
- ‚ö†Ô∏è Queries manuais quando necess√°rio
- ‚ö†Ô∏è Cuidado com circular references

---

**Pr√≥ximos passos**:
1. [Query Optimization](../performance/query-optimization.md) - Performance patterns
2. [Migration Relationships](../migrations/relationship-changes.md) - Altering relationships
3. [SQLAlchemy Patterns](../api/sqlalchemy-patterns.md) - Advanced usage
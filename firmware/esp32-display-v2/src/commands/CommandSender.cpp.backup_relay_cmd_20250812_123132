/**
 * @file CommandSender.cpp
 * @brief Implementação do gerenciador de comandos MQTT
 */

#include "commands/CommandSender.h"
#include "core/Logger.h"

extern Logger* logger;

CommandSender::CommandSender(MQTTClient* mqtt, const String& devId) 
    : mqttClient(mqtt), deviceId(devId), commandCounter(0) {
}

String CommandSender::generateRequestId() {
    commandCounter++;
    return deviceId + "_" + String(millis()) + "_" + String(commandCounter);
}

String CommandSender::getCurrentTimestamp() {
    // Formato simplificado para ESP32
    unsigned long currentMillis = millis();
    unsigned long seconds = currentMillis / 1000;
    unsigned long minutes = seconds / 60;
    unsigned long hours = minutes / 60;
    
    return String(hours) + ":" + String(minutes % 60) + ":" + String(seconds % 60);
}

bool CommandSender::sendCommand(NavButton* button) {
    if (!mqttClient || !mqttClient->isConnected()) {
        logger->warning("MQTT não conectado, comando não enviado");
        return false;
    }
    
    switch (button->getButtonType()) {
        case NavButton::TYPE_RELAY:
            // Para botões toggle, sempre aplicar debounce rigoroso
            if (button->getMode() == "toggle") {
                if (!button->canSendCommand()) {
                    logger->debug("Comando toggle ignorado devido ao debounce");
                    return false;
                }
                // Toggle state: se está ON, enviar OFF e vice-versa
                return sendRelayCommand(
                    button->getDeviceId(),
                    button->getChannel(),
                    button->getState() ? "OFF" : "ON",  // Toggle
                    false  // Não é momentary
                );
            } else {
                // Para botões momentary, permitir comandos repetidos mas com debounce menor
                return sendRelayCommand(
                    button->getDeviceId(),
                    button->getChannel(),
                    "ON",  // Momentary sempre ON
                    true   // É momentary
                );
            }
            
        case NavButton::TYPE_ACTION:
            if (button->getActionType() == "preset") {
                return sendPresetCommand(button->getPreset());
            }
            break;
            
        case NavButton::TYPE_MODE:
            return sendModeCommand(button->getModeValue());
            
        default:
            // Navegação é tratada localmente
            break;
    }
    
    return false;
}

bool CommandSender::sendRelayCommand(const String& targetDevice, int channel, 
                                   const String& state, bool momentary) {
    JsonDocument doc;
    
    doc["timestamp"] = getCurrentTimestamp();
    doc["device_id"] = deviceId;
    doc["request_id"] = generateRequestId();
    doc["action"] = "relay_command";
    doc["target"] = targetDevice;
    doc["channel"] = channel;
    doc["state"] = state;
    
    if (momentary) {
        doc["momentary"] = true;
    }
    
    // Enviar para o gateway, não direto para o dispositivo
    String topic = "autotech/gateway/command";
    String payload;
    serializeJson(doc, payload);
    
    logger->info("Enviando comando para gateway: " + payload);
    
    return mqttClient->publish(topic, payload);
}

bool CommandSender::sendPresetCommand(const String& preset) {
    JsonDocument doc;
    
    doc["timestamp"] = getCurrentTimestamp();
    doc["device_id"] = deviceId;
    doc["request_id"] = generateRequestId();
    doc["action"] = "preset";
    doc["preset"] = preset;
    
    String topic = "autotech/gateway/command";
    String payload;
    serializeJson(doc, payload);
    
    logger->info("Enviando preset: " + preset);
    
    return mqttClient->publish(topic, payload);
}

bool CommandSender::sendModeCommand(const String& mode) {
    JsonDocument doc;
    
    doc["timestamp"] = getCurrentTimestamp();
    doc["device_id"] = deviceId;
    doc["request_id"] = generateRequestId();
    doc["action"] = "set_mode";
    doc["mode"] = mode;
    
    String topic = "autotech/4x4_controller/command";
    String payload;
    serializeJson(doc, payload);
    
    logger->info("Enviando modo 4x4: " + mode);
    
    return mqttClient->publish(topic, payload);
}

bool CommandSender::sendActionCommand(const String& action, JsonObject& params) {
    JsonDocument doc;
    
    doc["timestamp"] = getCurrentTimestamp();
    doc["device_id"] = deviceId;
    doc["request_id"] = generateRequestId();
    doc["action"] = action;
    
    // Copiar parâmetros
    for (JsonPair kv : params) {
        doc[kv.key()] = kv.value();
    }
    
    String topic = "autotech/gateway/command";
    String payload;
    serializeJson(doc, payload);
    
    return mqttClient->publish(topic, payload);
}

void CommandSender::sendDisplayStatus(const String& currentScreen, int backlight) {
    JsonDocument doc;
    
    doc["timestamp"] = getCurrentTimestamp();
    doc["device_id"] = deviceId;
    doc["status"] = "online";
    doc["current_screen"] = currentScreen;
    doc["backlight"] = backlight;
    
    String topic = "autotech/" + deviceId + "/status";
    String payload;
    serializeJson(doc, payload);
    
    mqttClient->publish(topic, payload, true);  // Retained
}